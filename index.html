<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Статусы</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
    .top { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom: 12px; }
    input { padding: 8px 10px; border-radius: 10px; border:1px solid #ccc; min-width: 260px; }
    .meta { color:#666; font-size: 13px; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 8px; }
    .card { padding: 10px 12px; border-radius: 10px; border: 1px solid #ddd; background: #f3f3f3; color:#444; }
    .green { background: #e8f7ea; border-color: #bfe6c7; }
  </style>
</head>
<body>
  <div class="top">
    <input id="q" placeholder="Поиск по ФИО…" />
    <div class="meta" id="meta">Загрузка…</div>
  </div>

  <div class="grid" id="grid"></div>

<script>
  const grid = document.getElementById('grid');
  const meta = document.getElementById('meta');
  const q = document.getElementById('q');

  function norm(s){
    return (s ?? '').toString().trim().replace(/\s+/g, ' ');
  }

  function detectDelimiter(line) {
    const delims = [',', ';', '\t'];
    let best = ',', max = -1;
    for (const d of delims) {
      const c = (line.match(new RegExp('\\' + d, 'g')) || []).length;
      if (c > max) { max = c; best = d; }
    }
    return best;
  }

  function parseCSVLine(line, delim) {
    const out = [];
    let cur = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
      } else if (!inQuotes && ch === delim) {
        out.push(cur); cur = '';
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  const nodesByName = new Map(); // fio -> div

  function renderRow(fio, isGreen) {
    let node = nodesByName.get(fio);
    if (!node) {
      node = document.createElement('div');
      node.className = 'card';
      node.textContent = fio;
      node.dataset.name = fio.toLowerCase();
      grid.appendChild(node);
      nodesByName.set(fio, node);
    }
    node.className = isGreen ? 'card green' : 'card';
  }

  q.addEventListener('input', () => {
    const term = q.value.trim().toLowerCase();
    for (const el of grid.children) {
      el.style.display = term === '' || el.dataset.name.includes(term) ? '' : 'none';
    }
  });

  async function refresh() {
    try {
      const res = await fetch('status.csv?ts=' + Date.now(), { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status);

      const text = await res.text();
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
      if (lines.length < 2) throw new Error('CSV пустой');

      const delim = detectDelimiter(lines[0]);
      const header = parseCSVLine(lines[0], delim).map(h => norm(h).toLowerCase());
      const fioIdx = header.indexOf('fio');
      const ffIdx  = header.indexOf('ff');
      if (fioIdx === -1 || ffIdx === -1)
        throw new Error('В CSV должны быть колонки fio и ff');

      // сброс
      grid.innerHTML = '';
      nodesByName.clear();

      let greenCount = 0;

      for (let i = 1; i < lines.length; i++) {
        const cols = parseCSVLine(lines[i], delim);
        const fio = norm(cols[fioIdx] ?? '');
        const ff  = norm(cols[ffIdx] ?? '');
        if (!fio) continue;
        const isGreen = ff === '1';
        renderRow(fio, isGreen);
        if (isGreen) greenCount++;
      }

      meta.textContent =
        `Обновлено: ${new Date().toLocaleTimeString()} | Зеленых: ${greenCount}/${nodesByName.size}`;
    } catch (e) {
      meta.textContent = `Ошибка обновления: ${e.message}`;
    }
  }

  refresh();
  setInterval(refresh, 1 * 60 * 1000);
</script>
</body>
</html>
